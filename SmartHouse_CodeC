main.c
#include "stm32f4xx.h"

#define LCD_ADDR 0x4E 
#define SENSE_THRESHOLD 5 // Very low for instant reaction

/* ================= GLOBAL VARIABLES ================= */
volatile uint8_t ledOverride = 0;   

/* ================= PROTOTYPES ================= */
void GPIO_Config(void);
void EXTI14_Config(void);
void I2C_Config(void);
void I2C_Write(uint8_t addr, uint8_t data);
void LCD_SendCommand(char cmd);
void LCD_SendData(char data);
void LCD_Init(void);
void LCD_SendString(char *str);
void LCD_SetCursor(uint8_t row, uint8_t col);
void LCD_Clear(void);
void Delay_Ms(uint32_t ms);

/* ================= MAIN ================= */
int main(void) {
    GPIO_Config();
    I2C_Config();
    EXTI14_Config();
    LCD_Init();

    LCD_SetCursor(0, 1);
    LCD_SendString("SYSTEM ONLINE");
    Delay_Ms(500);
    LCD_Clear();

    int rainCounter = 0, darkCounter = 0;
    int stableRain = 0, stableDark = 0;
    int lastRain = -1, lastDark = -1, lastOvr = -1;
    int isMuted = 0;

    while (1) {
        // --- 1. SENSOR POLLING (ULTRA FAST) ---
        int rawRain = !(GPIOA->IDR & (1 << 0));  
        int rawDark = (GPIOA->IDR & (1 << 1));   
        int btnMute = !(GPIOC->IDR & (1 << 13)); 

        // --- 2. FAST DEBOUNCE ---
        if (rawRain) { if (rainCounter < SENSE_THRESHOLD) rainCounter++; }
        else { rainCounter = 0; stableRain = 0; }
        if (rainCounter >= SENSE_THRESHOLD) stableRain = 1;

        if (rawDark) { if (darkCounter < SENSE_THRESHOLD) darkCounter++; }
        else { darkCounter = 0; stableDark = 0; }
        if (darkCounter >= SENSE_THRESHOLD) stableDark = 1;

        // --- 3. SMART LCD UPDATE (ONLY ON CHANGE) ---
        // Writing to LCD takes time; only doing it when status flips makes sensors fast
        if (stableRain != lastRain) {
            LCD_SetCursor(0, 0);
            if (stableRain) LCD_SendString("WEATHER: RAIN   ");
            else           LCD_SendString("WEATHER: DRY    ");
            lastRain = stableRain;
        }

        if (stableDark != lastDark || ledOverride != lastOvr) {
            LCD_SetCursor(1, 0);
            if (stableDark) LCD_SendString("DARK ");
            else           LCD_SendString("DAY  ");
            
            if (ledOverride) LCD_SendString("[OVR ON] ");
            else            LCD_SendString("         ");
            
            lastDark = stableDark;
            lastOvr = ledOverride;
        }

        // --- 4. LED PA8-11 LOGIC ---
        if (stableDark ^ ledOverride) {
            GPIOA->BSRR = (0xF << (8 + 16)); // LEDs ON
        } else {
            GPIOA->BSRR = (0xF << 8);        // LEDs OFF
        }

        // --- 5. LOUD BUZZER TONE (BEEEEPP) ---
        if (stableRain) {
            GPIOC->BSRR = (1 << 11) | (1 << (12 + 16)); // Rain LED
            if (btnMute) isMuted = 1;

            if (!isMuted) {
                // High frequency toggle for loud sound
                GPIOD->BSRR = (1 << 2); 
                for(volatile int i = 0; i < 400; i++); // Pitch control
                GPIOD->BSRR = (1 << (2 + 16));
                for(volatile int i = 0; i < 400; i++);
            } else {
                GPIOD->BSRR = (1 << (2 + 16));
            }
        } else {
            GPIOC->BSRR = (1 << 12) | (1 << (11 + 16)); // Dry LED
            GPIOD->BSRR = (1 << (2 + 16));              
            isMuted = 0;
        }
    }
}

/* ================= INTERRUPT (PC14 OVERRIDE) ================= */
void EXTI15_10_IRQHandler(void) {
    if (EXTI->PR & (1 << 14)) {
        EXTI->PR |= (1 << 14);   
        ledOverride ^= 1;        
    }
}

/* ================= HARDWARE CONFIG ================= */
void EXTI14_Config(void) {
    RCC->APB2ENR |= (1 << 14);        
    SYSCFG->EXTICR[3] &= ~(0xF << 8); 
    SYSCFG->EXTICR[3] |= (2 << 8);    
    EXTI->IMR  |= (1 << 14);
    EXTI->FTSR |= (1 << 14);          
    NVIC_EnableIRQ(EXTI15_10_IRQn);
}

void GPIO_Config(void) {
    RCC->AHB1ENR |= 0x0F; 
    // PA0, PA1: Input; PA8-11: Output
    GPIOA->MODER &= ~((3 << 0) | (3 << 2) | (0xFF << 16));
    GPIOA->MODER |= (0x55 << 16);
    GPIOA->PUPDR |= (1 << 0) | (1 << 2);
    // PC11, 12: Output; PC13, 14: Input
    GPIOC->MODER &= ~((3 << 22) | (3 << 24) | (3 << 26) | (3 << 28));
    GPIOC->MODER |= ((1 << 22) | (1 << 24));
    GPIOC->PUPDR |= (1 << 26) | (1 << 28);
    // PD2: Buzzer
    GPIOD->MODER &= ~(3 << 4);
    GPIOD->MODER |= (1 << 4);
    // PB8, PB9: I2C
    GPIOB->MODER &= ~((3 << 16) | (3 << 18));
    GPIOB->MODER |= ((2 << 16) | (2 << 18));
    GPIOB->OTYPER |= (1 << 8) | (1 << 9);
    GPIOB->AFR[1] |= (4 << 0) | (4 << 4);
}

/* ================= LCD & I2C DRIVERS ================= */
void I2C_Config(void) {
    RCC->APB1ENR |= (1 << 21);
    I2C1->CR1 &= ~(1 << 0);
    I2C1->CR2 = 45; I2C1->CCR = 225; I2C1->TRISE = 46;
    I2C1->CR1 |= (1 << 0);
}

void I2C_Write(uint8_t addr, uint8_t data) {
    while (I2C1->SR2 & (1 << 1));
    I2C1->CR1 |= (1 << 8);
    while (!(I2C1->SR1 & (1 << 0)));
    I2C1->DR = addr;
    while (!(I2C1->SR1 & (1 << 1)));
    (void)I2C1->SR2;
    I2C1->DR = data;
    while (!(I2C1->SR1 & (1 << 7)));
    I2C1->CR1 |= (1 << 9);
}

void LCD_SendCommand(char cmd) {
    uint8_t upper = (cmd & 0xF0) | 0x08;
    I2C_Write(LCD_ADDR, upper | 0x04); I2C_Write(LCD_ADDR, upper);
    uint8_t lower = (cmd << 4) | 0x08;
    I2C_Write(LCD_ADDR, lower | 0x04); I2C_Write(LCD_ADDR, lower);
}

void LCD_SendData(char data) {
    uint8_t upper = (data & 0xF0) | 0x09;
    I2C_Write(LCD_ADDR, upper | 0x04); I2C_Write(LCD_ADDR, upper);
    uint8_t lower = (data << 4) | 0x09;
    I2C_Write(LCD_ADDR, lower | 0x04); I2C_Write(LCD_ADDR, lower);
}

void LCD_Init(void) {
    Delay_Ms(50);
    LCD_SendCommand(0x33); LCD_SendCommand(0x32);
    LCD_SendCommand(0x28); LCD_SendCommand(0x0C);
    LCD_SendCommand(0x06); LCD_Clear();
}

void LCD_SendString(char *str) { while (*str) LCD_SendData(*str++); }
void LCD_SetCursor(uint8_t row, uint8_t col) { LCD_SendCommand((row == 0 ? 0x80 : 0xC0) + col); }
void LCD_Clear(void) { LCD_SendCommand(0x01); Delay_Ms(2); }
void Delay_Ms(uint32_t ms) { for(uint32_t i=0; i<ms*18000; i++) __NOP(); }
